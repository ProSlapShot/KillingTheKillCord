
Softpot.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000012  00800100  000005c6  0000065a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000005c6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000d  00800112  00800112  0000066c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000066c  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000110  00000000  00000000  0000069c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000058d  00000000  00000000  000007ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000304  00000000  00000000  00000d39  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000004ad  00000000  00000000  0000103d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  0000036c  00000000  00000000  000014ec  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000002a3  00000000  00000000  00001858  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000065c  00000000  00000000  00001afb  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000000c0  00000000  00000000  00002157  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
#define F_CPU 12000000



void uart_init()
{
   0:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__ctors_end>
   4:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
	// Configure UART0 baud rate
	UBRR0H = (F_CPU/(UART_BAUD*16L)-1) >> 8;
   8:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
   c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
	UBRR0L = (F_CPU/(UART_BAUD*16L)-1);
  10:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  14:	0c 94 5d 00 	jmp	0xba	; 0xba <__vector_5>
  18:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
	
	UCSR0B = _BV(RXEN0) | _BV(RXCIE0);		// Enable UART0 receiver and RX complete interrupt
  1c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  20:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
	UCSR0C = _BV(UCSZ00) | _BV(UCSZ01);		// one start bit, 8-bit, no parity and one stop
  24:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  28:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  2c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
	
}
  30:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  34:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  38:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  3c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  40:	0c 94 25 02 	jmp	0x44a	; 0x44a <__vector_16>
  44:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  48:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  4c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  50:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  54:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  58:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  5c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  60:	0c 94 0c 01 	jmp	0x218	; 0x218 <__vector_24>
  64:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  68:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  6c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  70:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  74:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  78:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>

0000007c <__ctors_end>:
  7c:	11 24       	eor	r1, r1
  7e:	1f be       	out	0x3f, r1	; 63
  80:	cf ef       	ldi	r28, 0xFF	; 255
  82:	d0 e1       	ldi	r29, 0x10	; 16
  84:	de bf       	out	0x3e, r29	; 62
  86:	cd bf       	out	0x3d, r28	; 61

00000088 <__do_copy_data>:
  88:	11 e0       	ldi	r17, 0x01	; 1
  8a:	a0 e0       	ldi	r26, 0x00	; 0
  8c:	b1 e0       	ldi	r27, 0x01	; 1
  8e:	e6 ec       	ldi	r30, 0xC6	; 198
  90:	f5 e0       	ldi	r31, 0x05	; 5
  92:	02 c0       	rjmp	.+4      	; 0x98 <__do_copy_data+0x10>
  94:	05 90       	lpm	r0, Z+
  96:	0d 92       	st	X+, r0
  98:	a2 31       	cpi	r26, 0x12	; 18
  9a:	b1 07       	cpc	r27, r17
  9c:	d9 f7       	brne	.-10     	; 0x94 <__do_copy_data+0xc>

0000009e <__do_clear_bss>:
  9e:	21 e0       	ldi	r18, 0x01	; 1
  a0:	a2 e1       	ldi	r26, 0x12	; 18
  a2:	b1 e0       	ldi	r27, 0x01	; 1
  a4:	01 c0       	rjmp	.+2      	; 0xa8 <.do_clear_bss_start>

000000a6 <.do_clear_bss_loop>:
  a6:	1d 92       	st	X+, r1

000000a8 <.do_clear_bss_start>:
  a8:	af 31       	cpi	r26, 0x1F	; 31
  aa:	b2 07       	cpc	r27, r18
  ac:	e1 f7       	brne	.-8      	; 0xa6 <.do_clear_bss_loop>
  ae:	0e 94 c3 01 	call	0x386	; 0x386 <main>
  b2:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <_exit>

000000b6 <__bad_interrupt>:
  b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ba <__vector_5>:
	tmp = (BTN_PIN & pins);		// Initial button status
}


ISR(PCINT1_vect)  //interrupt for pin A0
{
  ba:	1f 92       	push	r1
  bc:	0f 92       	push	r0
  be:	00 90 5f 00 	lds	r0, 0x005F
  c2:	0f 92       	push	r0
  c4:	11 24       	eor	r1, r1
  c6:	8f 93       	push	r24
  c8:	9f 93       	push	r25
  ca:	ef 93       	push	r30
  cc:	ff 93       	push	r31
  ce:	cf 93       	push	r28
  d0:	df 93       	push	r29
  d2:	cd b7       	in	r28, 0x3d	; 61
  d4:	de b7       	in	r29, 0x3e	; 62
	waiting |= (BTN_PIN & pins) ^ tmp;		//Need to mask pins
  d6:	83 e2       	ldi	r24, 0x23	; 35
  d8:	90 e0       	ldi	r25, 0x00	; 0
  da:	fc 01       	movw	r30, r24
  dc:	90 81       	ld	r25, Z
  de:	80 91 08 01 	lds	r24, 0x0108
  e2:	98 23       	and	r25, r24
  e4:	80 91 09 01 	lds	r24, 0x0109
  e8:	98 27       	eor	r25, r24
  ea:	80 91 12 01 	lds	r24, 0x0112
  ee:	89 2b       	or	r24, r25
  f0:	80 93 12 01 	sts	0x0112, r24
	tmp = (BTN_PIN & pins);
  f4:	83 e2       	ldi	r24, 0x23	; 35
  f6:	90 e0       	ldi	r25, 0x00	; 0
  f8:	fc 01       	movw	r30, r24
  fa:	90 81       	ld	r25, Z
  fc:	80 91 08 01 	lds	r24, 0x0108
 100:	89 23       	and	r24, r25
 102:	80 93 09 01 	sts	0x0109, r24
}
 106:	df 91       	pop	r29
 108:	cf 91       	pop	r28
 10a:	ff 91       	pop	r31
 10c:	ef 91       	pop	r30
 10e:	9f 91       	pop	r25
 110:	8f 91       	pop	r24
 112:	0f 90       	pop	r0
 114:	00 92 5f 00 	sts	0x005F, r0
 118:	0f 90       	pop	r0
 11a:	1f 90       	pop	r1
 11c:	18 95       	reti

0000011e <check_button_status>:

void check_button_status()
{
 11e:	cf 93       	push	r28
 120:	df 93       	push	r29
 122:	00 d0       	rcall	.+0      	; 0x124 <check_button_status+0x6>
 124:	cd b7       	in	r28, 0x3d	; 61
 126:	de b7       	in	r29, 0x3e	; 62
	
	if (waiting)
 128:	80 91 12 01 	lds	r24, 0x0112
 12c:	88 23       	and	r24, r24
 12e:	09 f4       	brne	.+2      	; 0x132 <check_button_status+0x14>
 130:	4c c0       	rjmp	.+152    	; 0x1ca <check_button_status+0xac>
	{
		uint8_t i = 0;
 132:	19 82       	std	Y+1, r1	; 0x01
		
		do
		{
			uint8_t mask = (1 << i);
 134:	89 81       	ldd	r24, Y+1	; 0x01
 136:	28 2f       	mov	r18, r24
 138:	30 e0       	ldi	r19, 0x00	; 0
 13a:	81 e0       	ldi	r24, 0x01	; 1
 13c:	90 e0       	ldi	r25, 0x00	; 0
 13e:	02 2e       	mov	r0, r18
 140:	02 c0       	rjmp	.+4      	; 0x146 <check_button_status+0x28>
 142:	88 0f       	add	r24, r24
 144:	99 1f       	adc	r25, r25
 146:	0a 94       	dec	r0
 148:	e2 f7       	brpl	.-8      	; 0x142 <check_button_status+0x24>
 14a:	8a 83       	std	Y+2, r24	; 0x02
			if (waiting & mask)
 14c:	90 91 12 01 	lds	r25, 0x0112
 150:	8a 81       	ldd	r24, Y+2	; 0x02
 152:	89 23       	and	r24, r25
 154:	88 23       	and	r24, r24
 156:	91 f1       	breq	.+100    	; 0x1bc <check_button_status+0x9e>
			{
				waiting &= ~mask;
 158:	8a 81       	ldd	r24, Y+2	; 0x02
 15a:	98 2f       	mov	r25, r24
 15c:	90 95       	com	r25
 15e:	80 91 12 01 	lds	r24, 0x0112
 162:	89 23       	and	r24, r25
 164:	80 93 12 01 	sts	0x0112, r24
				if(mappings[i] != 0)
 168:	89 81       	ldd	r24, Y+1	; 0x01
 16a:	88 2f       	mov	r24, r24
 16c:	90 e0       	ldi	r25, 0x00	; 0
 16e:	80 50       	subi	r24, 0x00	; 0
 170:	9f 4f       	sbci	r25, 0xFF	; 255
 172:	fc 01       	movw	r30, r24
 174:	80 81       	ld	r24, Z
 176:	88 23       	and	r24, r24
 178:	09 f1       	breq	.+66     	; 0x1bc <check_button_status+0x9e>
				{
					if ((BTN_PIN & pins) & mask)
 17a:	83 e2       	ldi	r24, 0x23	; 35
 17c:	90 e0       	ldi	r25, 0x00	; 0
 17e:	fc 01       	movw	r30, r24
 180:	90 81       	ld	r25, Z
 182:	80 91 08 01 	lds	r24, 0x0108
 186:	98 23       	and	r25, r24
 188:	8a 81       	ldd	r24, Y+2	; 0x02
 18a:	89 23       	and	r24, r25
 18c:	88 23       	and	r24, r24
 18e:	b1 f4       	brne	.+44     	; 0x1bc <check_button_status+0x9e>
					{
						/* Button depress action */
					}
					else
					{
						if(mappings[i] == 1)
 190:	89 81       	ldd	r24, Y+1	; 0x01
 192:	88 2f       	mov	r24, r24
 194:	90 e0       	ldi	r25, 0x00	; 0
 196:	80 50       	subi	r24, 0x00	; 0
 198:	9f 4f       	sbci	r25, 0xFF	; 255
 19a:	fc 01       	movw	r30, r24
 19c:	80 81       	ld	r24, Z
 19e:	81 30       	cpi	r24, 0x01	; 1
 1a0:	11 f4       	brne	.+4      	; 0x1a6 <check_button_status+0x88>
							engine_start();		
 1a2:	0e 94 bc 02 	call	0x578	; 0x578 <engine_start>
						if(mappings[i] == 2)
 1a6:	89 81       	ldd	r24, Y+1	; 0x01
 1a8:	88 2f       	mov	r24, r24
 1aa:	90 e0       	ldi	r25, 0x00	; 0
 1ac:	80 50       	subi	r24, 0x00	; 0
 1ae:	9f 4f       	sbci	r25, 0xFF	; 255
 1b0:	fc 01       	movw	r30, r24
 1b2:	80 81       	ld	r24, Z
 1b4:	82 30       	cpi	r24, 0x02	; 2
 1b6:	11 f4       	brne	.+4      	; 0x1bc <check_button_status+0x9e>
							calibrate();
 1b8:	0e 94 b6 01 	call	0x36c	; 0x36c <calibrate>
					}
				}
			}
		} while(i++ != 7);
 1bc:	89 81       	ldd	r24, Y+1	; 0x01
 1be:	91 e0       	ldi	r25, 0x01	; 1
 1c0:	98 0f       	add	r25, r24
 1c2:	99 83       	std	Y+1, r25	; 0x01
 1c4:	87 30       	cpi	r24, 0x07	; 7
 1c6:	09 f0       	breq	.+2      	; 0x1ca <check_button_status+0xac>
 1c8:	b5 cf       	rjmp	.-150    	; 0x134 <check_button_status+0x16>
	}
 1ca:	0f 90       	pop	r0
 1cc:	0f 90       	pop	r0
 1ce:	df 91       	pop	r29
 1d0:	cf 91       	pop	r28
 1d2:	08 95       	ret

000001d4 <adc_init>:

int cal = 1;


void adc_init()
{
 1d4:	cf 93       	push	r28
 1d6:	df 93       	push	r29
 1d8:	cd b7       	in	r28, 0x3d	; 61
 1da:	de b7       	in	r29, 0x3e	; 62
	ADCSRA = _BV(ADEN) | _BV(ADIE) | _BV(ADPS2) | _BV(ADPS1);	//Enable ADC with prescaler of 64 & interrupt
 1dc:	8a e7       	ldi	r24, 0x7A	; 122
 1de:	90 e0       	ldi	r25, 0x00	; 0
 1e0:	2e e8       	ldi	r18, 0x8E	; 142
 1e2:	fc 01       	movw	r30, r24
 1e4:	20 83       	st	Z, r18
	ADMUX = wheel;												//AVCC, initializes on ADC0
 1e6:	8c e7       	ldi	r24, 0x7C	; 124
 1e8:	90 e0       	ldi	r25, 0x00	; 0
 1ea:	20 91 0a 01 	lds	r18, 0x010A
 1ee:	fc 01       	movw	r30, r24
 1f0:	20 83       	st	Z, r18
}
 1f2:	df 91       	pop	r29
 1f4:	cf 91       	pop	r28
 1f6:	08 95       	ret

000001f8 <adc_conv>:

void adc_conv()
{
 1f8:	cf 93       	push	r28
 1fa:	df 93       	push	r29
 1fc:	cd b7       	in	r28, 0x3d	; 61
 1fe:	de b7       	in	r29, 0x3e	; 62
	ADCSRA |= _BV(ADSC);
 200:	8a e7       	ldi	r24, 0x7A	; 122
 202:	90 e0       	ldi	r25, 0x00	; 0
 204:	2a e7       	ldi	r18, 0x7A	; 122
 206:	30 e0       	ldi	r19, 0x00	; 0
 208:	f9 01       	movw	r30, r18
 20a:	20 81       	ld	r18, Z
 20c:	20 64       	ori	r18, 0x40	; 64
 20e:	fc 01       	movw	r30, r24
 210:	20 83       	st	Z, r18
}
 212:	df 91       	pop	r29
 214:	cf 91       	pop	r28
 216:	08 95       	ret

00000218 <__vector_24>:
	throttle_cal = adc_value();
	ADMUX = wheel;
}

ISR(ADC_vect)
{
 218:	1f 92       	push	r1
 21a:	0f 92       	push	r0
 21c:	00 90 5f 00 	lds	r0, 0x005F
 220:	0f 92       	push	r0
 222:	11 24       	eor	r1, r1
 224:	2f 93       	push	r18
 226:	3f 93       	push	r19
 228:	4f 93       	push	r20
 22a:	5f 93       	push	r21
 22c:	6f 93       	push	r22
 22e:	7f 93       	push	r23
 230:	8f 93       	push	r24
 232:	9f 93       	push	r25
 234:	af 93       	push	r26
 236:	bf 93       	push	r27
 238:	ef 93       	push	r30
 23a:	ff 93       	push	r31
 23c:	cf 93       	push	r28
 23e:	df 93       	push	r29
 240:	00 d0       	rcall	.+0      	; 0x242 <__vector_24+0x2a>
 242:	cd b7       	in	r28, 0x3d	; 61
 244:	de b7       	in	r29, 0x3e	; 62
	
	
		uint16_t result = ADCL | (ADCH <<8);		// Take ADC result
 246:	88 e7       	ldi	r24, 0x78	; 120
 248:	90 e0       	ldi	r25, 0x00	; 0
 24a:	fc 01       	movw	r30, r24
 24c:	80 81       	ld	r24, Z
 24e:	28 2f       	mov	r18, r24
 250:	30 e0       	ldi	r19, 0x00	; 0
 252:	89 e7       	ldi	r24, 0x79	; 121
 254:	90 e0       	ldi	r25, 0x00	; 0
 256:	fc 01       	movw	r30, r24
 258:	80 81       	ld	r24, Z
 25a:	88 2f       	mov	r24, r24
 25c:	90 e0       	ldi	r25, 0x00	; 0
 25e:	98 2f       	mov	r25, r24
 260:	88 27       	eor	r24, r24
 262:	82 2b       	or	r24, r18
 264:	93 2b       	or	r25, r19
 266:	9a 83       	std	Y+2, r25	; 0x02
 268:	89 83       	std	Y+1, r24	; 0x01
	
		if(ADMUX == wheel)
 26a:	8c e7       	ldi	r24, 0x7C	; 124
 26c:	90 e0       	ldi	r25, 0x00	; 0
 26e:	fc 01       	movw	r30, r24
 270:	90 81       	ld	r25, Z
 272:	80 91 0a 01 	lds	r24, 0x010A
 276:	98 17       	cp	r25, r24
 278:	39 f5       	brne	.+78     	; 0x2c8 <__vector_24+0xb0>
		{
			if(cal)
 27a:	80 91 10 01 	lds	r24, 0x0110
 27e:	90 91 11 01 	lds	r25, 0x0111
 282:	00 97       	sbiw	r24, 0x00	; 0
 284:	39 f0       	breq	.+14     	; 0x294 <__vector_24+0x7c>
				wheel_cal = result;
 286:	89 81       	ldd	r24, Y+1	; 0x01
 288:	9a 81       	ldd	r25, Y+2	; 0x02
 28a:	90 93 0d 01 	sts	0x010D, r25
 28e:	80 93 0c 01 	sts	0x010C, r24
 292:	11 c0       	rjmp	.+34     	; 0x2b6 <__vector_24+0x9e>
			else
			{
				if(result > (wheel_cal + 25))		//25 is ballpark value, don't want false detection from noise
 294:	80 91 0c 01 	lds	r24, 0x010C
 298:	90 91 0d 01 	lds	r25, 0x010D
 29c:	9c 01       	movw	r18, r24
 29e:	27 5e       	subi	r18, 0xE7	; 231
 2a0:	3f 4f       	sbci	r19, 0xFF	; 255
 2a2:	89 81       	ldd	r24, Y+1	; 0x01
 2a4:	9a 81       	ldd	r25, Y+2	; 0x02
 2a6:	28 17       	cp	r18, r24
 2a8:	39 07       	cpc	r19, r25
 2aa:	18 f4       	brcc	.+6      	; 0x2b2 <__vector_24+0x9a>
					reset_wheel_flag();
 2ac:	0e 94 f5 01 	call	0x3ea	; 0x3ea <reset_wheel_flag>
 2b0:	02 c0       	rjmp	.+4      	; 0x2b6 <__vector_24+0x9e>
				else
					set_wheel_flag();
 2b2:	0e 94 00 02 	call	0x400	; 0x400 <set_wheel_flag>
			}
			ADMUX = throttle;
 2b6:	8c e7       	ldi	r24, 0x7C	; 124
 2b8:	90 e0       	ldi	r25, 0x00	; 0
 2ba:	20 91 0b 01 	lds	r18, 0x010B
 2be:	fc 01       	movw	r30, r24
 2c0:	20 83       	st	Z, r18
			adc_conv();
 2c2:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <adc_conv>
 2c6:	3c c0       	rjmp	.+120    	; 0x340 <__vector_24+0x128>
		}
		
		else if(ADMUX == throttle)
 2c8:	8c e7       	ldi	r24, 0x7C	; 124
 2ca:	90 e0       	ldi	r25, 0x00	; 0
 2cc:	fc 01       	movw	r30, r24
 2ce:	90 81       	ld	r25, Z
 2d0:	80 91 0b 01 	lds	r24, 0x010B
 2d4:	98 17       	cp	r25, r24
 2d6:	59 f5       	brne	.+86     	; 0x32e <__vector_24+0x116>
		{
			if(!cal)
 2d8:	80 91 10 01 	lds	r24, 0x0110
 2dc:	90 91 11 01 	lds	r25, 0x0111
 2e0:	00 97       	sbiw	r24, 0x00	; 0
 2e2:	91 f4       	brne	.+36     	; 0x308 <__vector_24+0xf0>
			{
				if(result > (throttle_cal + 25))
 2e4:	80 91 0e 01 	lds	r24, 0x010E
 2e8:	90 91 0f 01 	lds	r25, 0x010F
 2ec:	9c 01       	movw	r18, r24
 2ee:	27 5e       	subi	r18, 0xE7	; 231
 2f0:	3f 4f       	sbci	r19, 0xFF	; 255
 2f2:	89 81       	ldd	r24, Y+1	; 0x01
 2f4:	9a 81       	ldd	r25, Y+2	; 0x02
 2f6:	28 17       	cp	r18, r24
 2f8:	39 07       	cpc	r19, r25
 2fa:	18 f4       	brcc	.+6      	; 0x302 <__vector_24+0xea>
					reset_throttle_flag();
 2fc:	0e 94 0d 02 	call	0x41a	; 0x41a <reset_throttle_flag>
 300:	0d c0       	rjmp	.+26     	; 0x31c <__vector_24+0x104>
				else
					set_throttle_flag();	
 302:	0e 94 18 02 	call	0x430	; 0x430 <set_throttle_flag>
 306:	0a c0       	rjmp	.+20     	; 0x31c <__vector_24+0x104>

			}
			else 
			{
				throttle_cal = result;
 308:	89 81       	ldd	r24, Y+1	; 0x01
 30a:	9a 81       	ldd	r25, Y+2	; 0x02
 30c:	90 93 0f 01 	sts	0x010F, r25
 310:	80 93 0e 01 	sts	0x010E, r24
					cal = 0;
 314:	10 92 11 01 	sts	0x0111, r1
 318:	10 92 10 01 	sts	0x0110, r1
			}
			ADMUX = wheel;	
 31c:	8c e7       	ldi	r24, 0x7C	; 124
 31e:	90 e0       	ldi	r25, 0x00	; 0
 320:	20 91 0a 01 	lds	r18, 0x010A
 324:	fc 01       	movw	r30, r24
 326:	20 83       	st	Z, r18
			adc_conv();
 328:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <adc_conv>
 32c:	09 c0       	rjmp	.+18     	; 0x340 <__vector_24+0x128>
		}
		else
			PINB |= _BV(PB7);
 32e:	83 e2       	ldi	r24, 0x23	; 35
 330:	90 e0       	ldi	r25, 0x00	; 0
 332:	23 e2       	ldi	r18, 0x23	; 35
 334:	30 e0       	ldi	r19, 0x00	; 0
 336:	f9 01       	movw	r30, r18
 338:	20 81       	ld	r18, Z
 33a:	20 68       	ori	r18, 0x80	; 128
 33c:	fc 01       	movw	r30, r24
 33e:	20 83       	st	Z, r18

}
 340:	0f 90       	pop	r0
 342:	0f 90       	pop	r0
 344:	df 91       	pop	r29
 346:	cf 91       	pop	r28
 348:	ff 91       	pop	r31
 34a:	ef 91       	pop	r30
 34c:	bf 91       	pop	r27
 34e:	af 91       	pop	r26
 350:	9f 91       	pop	r25
 352:	8f 91       	pop	r24
 354:	7f 91       	pop	r23
 356:	6f 91       	pop	r22
 358:	5f 91       	pop	r21
 35a:	4f 91       	pop	r20
 35c:	3f 91       	pop	r19
 35e:	2f 91       	pop	r18
 360:	0f 90       	pop	r0
 362:	00 92 5f 00 	sts	0x005F, r0
 366:	0f 90       	pop	r0
 368:	1f 90       	pop	r1
 36a:	18 95       	reti

0000036c <calibrate>:

void calibrate()
{
 36c:	cf 93       	push	r28
 36e:	df 93       	push	r29
 370:	cd b7       	in	r28, 0x3d	; 61
 372:	de b7       	in	r29, 0x3e	; 62
	cal = 1;
 374:	81 e0       	ldi	r24, 0x01	; 1
 376:	90 e0       	ldi	r25, 0x00	; 0
 378:	90 93 11 01 	sts	0x0111, r25
 37c:	80 93 10 01 	sts	0x0110, r24
 380:	df 91       	pop	r29
 382:	cf 91       	pop	r28
 384:	08 95       	ret

00000386 <main>:
#include "buttons.h"



int main(void)
{
 386:	cf 93       	push	r28
 388:	df 93       	push	r29
 38a:	cd b7       	in	r28, 0x3d	; 61
 38c:	de b7       	in	r29, 0x3e	; 62
	
	DDRB |= _BV(PB7);	//LED lights up when engine is off
 38e:	84 e2       	ldi	r24, 0x24	; 36
 390:	90 e0       	ldi	r25, 0x00	; 0
 392:	24 e2       	ldi	r18, 0x24	; 36
 394:	30 e0       	ldi	r19, 0x00	; 0
 396:	f9 01       	movw	r30, r18
 398:	20 81       	ld	r18, Z
 39a:	20 68       	ori	r18, 0x80	; 128
 39c:	fc 01       	movw	r30, r24
 39e:	20 83       	st	Z, r18
	//PORTB |= _BV(PB7);
	//DDRD ^= ~_BV(PD2);	//Engine on button
	//PORTD |= _BV(PD2); //Enable pull up
	
	adc_init();
 3a0:	0e 94 ea 00 	call	0x1d4	; 0x1d4 <adc_init>
	timer_init();
 3a4:	0e 94 da 01 	call	0x3b4	; 0x3b4 <timer_init>
	
	timer_init();
 3a8:	0e 94 da 01 	call	0x3b4	; 0x3b4 <timer_init>
	sei();
 3ac:	78 94       	sei
	
	adc_conv();		// starts continuous conversions between ADC
 3ae:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <adc_conv>
	
    while(1)
    {
	
    }
 3b2:	ff cf       	rjmp	.-2      	; 0x3b2 <main+0x2c>

000003b4 <timer_init>:
int throttle_flag = 0;
int wheel_flag = 0;
int led_flash = 0;

void timer_init()
{
 3b4:	cf 93       	push	r28
 3b6:	df 93       	push	r29
 3b8:	cd b7       	in	r28, 0x3d	; 61
 3ba:	de b7       	in	r29, 0x3e	; 62
	OCR0A = F_CPU / 1024 / timer_freq;   // Set up compare value for 50 Hz interrupt generation.
 3bc:	87 e4       	ldi	r24, 0x47	; 71
 3be:	90 e0       	ldi	r25, 0x00	; 0
 3c0:	2a ee       	ldi	r18, 0xEA	; 234
 3c2:	fc 01       	movw	r30, r24
 3c4:	20 83       	st	Z, r18
	TCCR0A = (1 << WGM01);               // Enable CTC mode
 3c6:	84 e4       	ldi	r24, 0x44	; 68
 3c8:	90 e0       	ldi	r25, 0x00	; 0
 3ca:	22 e0       	ldi	r18, 0x02	; 2
 3cc:	fc 01       	movw	r30, r24
 3ce:	20 83       	st	Z, r18
	TIMSK0 = _BV(OCIE0A);                // Enable Timer0 Compare Match A interrupt
 3d0:	8e e6       	ldi	r24, 0x6E	; 110
 3d2:	90 e0       	ldi	r25, 0x00	; 0
 3d4:	22 e0       	ldi	r18, 0x02	; 2
 3d6:	fc 01       	movw	r30, r24
 3d8:	20 83       	st	Z, r18
	TCCR0B = (1 << CS02) | (0 << CS01) | (1 << CS00); // Initilise timer1 with /1024 prescaler	
 3da:	85 e4       	ldi	r24, 0x45	; 69
 3dc:	90 e0       	ldi	r25, 0x00	; 0
 3de:	25 e0       	ldi	r18, 0x05	; 5
 3e0:	fc 01       	movw	r30, r24
 3e2:	20 83       	st	Z, r18
}
 3e4:	df 91       	pop	r29
 3e6:	cf 91       	pop	r28
 3e8:	08 95       	ret

000003ea <reset_wheel_flag>:

void reset_wheel_flag()
{
 3ea:	cf 93       	push	r28
 3ec:	df 93       	push	r29
 3ee:	cd b7       	in	r28, 0x3d	; 61
 3f0:	de b7       	in	r29, 0x3e	; 62
	wheel_flag = 0;
 3f2:	10 92 1c 01 	sts	0x011C, r1
 3f6:	10 92 1b 01 	sts	0x011B, r1
}
 3fa:	df 91       	pop	r29
 3fc:	cf 91       	pop	r28
 3fe:	08 95       	ret

00000400 <set_wheel_flag>:

void set_wheel_flag()
{
 400:	cf 93       	push	r28
 402:	df 93       	push	r29
 404:	cd b7       	in	r28, 0x3d	; 61
 406:	de b7       	in	r29, 0x3e	; 62
	wheel_flag = 1;
 408:	81 e0       	ldi	r24, 0x01	; 1
 40a:	90 e0       	ldi	r25, 0x00	; 0
 40c:	90 93 1c 01 	sts	0x011C, r25
 410:	80 93 1b 01 	sts	0x011B, r24
}
 414:	df 91       	pop	r29
 416:	cf 91       	pop	r28
 418:	08 95       	ret

0000041a <reset_throttle_flag>:

void reset_throttle_flag()
{
 41a:	cf 93       	push	r28
 41c:	df 93       	push	r29
 41e:	cd b7       	in	r28, 0x3d	; 61
 420:	de b7       	in	r29, 0x3e	; 62
	throttle_flag = 0;
 422:	10 92 1a 01 	sts	0x011A, r1
 426:	10 92 19 01 	sts	0x0119, r1
}
 42a:	df 91       	pop	r29
 42c:	cf 91       	pop	r28
 42e:	08 95       	ret

00000430 <set_throttle_flag>:

void set_throttle_flag()
{
 430:	cf 93       	push	r28
 432:	df 93       	push	r29
 434:	cd b7       	in	r28, 0x3d	; 61
 436:	de b7       	in	r29, 0x3e	; 62
	throttle_flag = 1;
 438:	81 e0       	ldi	r24, 0x01	; 1
 43a:	90 e0       	ldi	r25, 0x00	; 0
 43c:	90 93 1a 01 	sts	0x011A, r25
 440:	80 93 19 01 	sts	0x0119, r24
}
 444:	df 91       	pop	r29
 446:	cf 91       	pop	r28
 448:	08 95       	ret

0000044a <__vector_16>:

ISR(TIMER0_COMPA_vect)
{
 44a:	1f 92       	push	r1
 44c:	0f 92       	push	r0
 44e:	00 90 5f 00 	lds	r0, 0x005F
 452:	0f 92       	push	r0
 454:	11 24       	eor	r1, r1
 456:	2f 93       	push	r18
 458:	3f 93       	push	r19
 45a:	4f 93       	push	r20
 45c:	5f 93       	push	r21
 45e:	6f 93       	push	r22
 460:	7f 93       	push	r23
 462:	8f 93       	push	r24
 464:	9f 93       	push	r25
 466:	af 93       	push	r26
 468:	bf 93       	push	r27
 46a:	ef 93       	push	r30
 46c:	ff 93       	push	r31
 46e:	cf 93       	push	r28
 470:	df 93       	push	r29
 472:	cd b7       	in	r28, 0x3d	; 61
 474:	de b7       	in	r29, 0x3e	; 62
	/* Check length of time controls are left untouched */
	
	if(throttle_flag | wheel_flag)
 476:	20 91 19 01 	lds	r18, 0x0119
 47a:	30 91 1a 01 	lds	r19, 0x011A
 47e:	80 91 1b 01 	lds	r24, 0x011B
 482:	90 91 1c 01 	lds	r25, 0x011C
 486:	82 2b       	or	r24, r18
 488:	93 2b       	or	r25, r19
 48a:	00 97       	sbiw	r24, 0x00	; 0
 48c:	d1 f0       	breq	.+52     	; 0x4c2 <__vector_16+0x78>
	{
		count ++;
 48e:	80 91 13 01 	lds	r24, 0x0113
 492:	90 91 14 01 	lds	r25, 0x0114
 496:	01 96       	adiw	r24, 0x01	; 1
 498:	90 93 14 01 	sts	0x0114, r25
 49c:	80 93 13 01 	sts	0x0113, r24
		if(count == 250)		// can be changed depending on delay 
 4a0:	80 91 13 01 	lds	r24, 0x0113
 4a4:	90 91 14 01 	lds	r25, 0x0114
 4a8:	8a 3f       	cpi	r24, 0xFA	; 250
 4aa:	91 05       	cpc	r25, r1
 4ac:	71 f4       	brne	.+28     	; 0x4ca <__vector_16+0x80>
			PORTB |= _BV(PB7);
 4ae:	85 e2       	ldi	r24, 0x25	; 37
 4b0:	90 e0       	ldi	r25, 0x00	; 0
 4b2:	25 e2       	ldi	r18, 0x25	; 37
 4b4:	30 e0       	ldi	r19, 0x00	; 0
 4b6:	f9 01       	movw	r30, r18
 4b8:	20 81       	ld	r18, Z
 4ba:	20 68       	ori	r18, 0x80	; 128
 4bc:	fc 01       	movw	r30, r24
 4be:	20 83       	st	Z, r18
 4c0:	04 c0       	rjmp	.+8      	; 0x4ca <__vector_16+0x80>
	}
	else
	count = 0;
 4c2:	10 92 14 01 	sts	0x0114, r1
 4c6:	10 92 13 01 	sts	0x0113, r1
	
	/* Debouncing for input buttons */
	check_button_status();
 4ca:	0e 94 8f 00 	call	0x11e	; 0x11e <check_button_status>
	
	/*Flash LED on unsuccessful start up*/
	if(led_flash)
 4ce:	80 91 1d 01 	lds	r24, 0x011D
 4d2:	90 91 1e 01 	lds	r25, 0x011E
 4d6:	00 97       	sbiw	r24, 0x00	; 0
 4d8:	d9 f1       	breq	.+118    	; 0x550 <__vector_16+0x106>
	{
		if(i>=25)
 4da:	80 91 15 01 	lds	r24, 0x0115
 4de:	90 91 16 01 	lds	r25, 0x0116
 4e2:	89 31       	cpi	r24, 0x19	; 25
 4e4:	91 05       	cpc	r25, r1
 4e6:	9c f0       	brlt	.+38     	; 0x50e <__vector_16+0xc4>
		{
			PINB |= _BV(PB7);
 4e8:	83 e2       	ldi	r24, 0x23	; 35
 4ea:	90 e0       	ldi	r25, 0x00	; 0
 4ec:	23 e2       	ldi	r18, 0x23	; 35
 4ee:	30 e0       	ldi	r19, 0x00	; 0
 4f0:	f9 01       	movw	r30, r18
 4f2:	20 81       	ld	r18, Z
 4f4:	20 68       	ori	r18, 0x80	; 128
 4f6:	fc 01       	movw	r30, r24
 4f8:	20 83       	st	Z, r18
			i++;
 4fa:	80 91 15 01 	lds	r24, 0x0115
 4fe:	90 91 16 01 	lds	r25, 0x0116
 502:	01 96       	adiw	r24, 0x01	; 1
 504:	90 93 16 01 	sts	0x0116, r25
 508:	80 93 15 01 	sts	0x0115, r24
 50c:	0d c0       	rjmp	.+26     	; 0x528 <__vector_16+0xde>
		}
		else
		{
			i = 0;
 50e:	10 92 16 01 	sts	0x0116, r1
 512:	10 92 15 01 	sts	0x0115, r1
			flash_count++;			
 516:	80 91 17 01 	lds	r24, 0x0117
 51a:	90 91 18 01 	lds	r25, 0x0118
 51e:	01 96       	adiw	r24, 0x01	; 1
 520:	90 93 18 01 	sts	0x0118, r25
 524:	80 93 17 01 	sts	0x0117, r24
		}
		if (flash_count >= 6)
 528:	80 91 17 01 	lds	r24, 0x0117
 52c:	90 91 18 01 	lds	r25, 0x0118
 530:	86 30       	cpi	r24, 0x06	; 6
 532:	91 05       	cpc	r25, r1
 534:	6c f0       	brlt	.+26     	; 0x550 <__vector_16+0x106>
		{
			led_flash = 0;
 536:	10 92 1e 01 	sts	0x011E, r1
 53a:	10 92 1d 01 	sts	0x011D, r1
			PORTB |= _BV(PB7);
 53e:	85 e2       	ldi	r24, 0x25	; 37
 540:	90 e0       	ldi	r25, 0x00	; 0
 542:	25 e2       	ldi	r18, 0x25	; 37
 544:	30 e0       	ldi	r19, 0x00	; 0
 546:	f9 01       	movw	r30, r18
 548:	20 81       	ld	r18, Z
 54a:	20 68       	ori	r18, 0x80	; 128
 54c:	fc 01       	movw	r30, r24
 54e:	20 83       	st	Z, r18
		}
	}
}
 550:	df 91       	pop	r29
 552:	cf 91       	pop	r28
 554:	ff 91       	pop	r31
 556:	ef 91       	pop	r30
 558:	bf 91       	pop	r27
 55a:	af 91       	pop	r26
 55c:	9f 91       	pop	r25
 55e:	8f 91       	pop	r24
 560:	7f 91       	pop	r23
 562:	6f 91       	pop	r22
 564:	5f 91       	pop	r21
 566:	4f 91       	pop	r20
 568:	3f 91       	pop	r19
 56a:	2f 91       	pop	r18
 56c:	0f 90       	pop	r0
 56e:	00 92 5f 00 	sts	0x005F, r0
 572:	0f 90       	pop	r0
 574:	1f 90       	pop	r1
 576:	18 95       	reti

00000578 <engine_start>:

void engine_start()
{
 578:	cf 93       	push	r28
 57a:	df 93       	push	r29
 57c:	cd b7       	in	r28, 0x3d	; 61
 57e:	de b7       	in	r29, 0x3e	; 62
	if(!(throttle_flag|wheel_flag))
 580:	20 91 19 01 	lds	r18, 0x0119
 584:	30 91 1a 01 	lds	r19, 0x011A
 588:	80 91 1b 01 	lds	r24, 0x011B
 58c:	90 91 1c 01 	lds	r25, 0x011C
 590:	82 2b       	or	r24, r18
 592:	93 2b       	or	r25, r19
 594:	00 97       	sbiw	r24, 0x00	; 0
 596:	61 f4       	brne	.+24     	; 0x5b0 <engine_start+0x38>
		{
			PORTB ^= ~_BV(PB7);			//LED shows status of engine
 598:	85 e2       	ldi	r24, 0x25	; 37
 59a:	90 e0       	ldi	r25, 0x00	; 0
 59c:	25 e2       	ldi	r18, 0x25	; 37
 59e:	30 e0       	ldi	r19, 0x00	; 0
 5a0:	f9 01       	movw	r30, r18
 5a2:	20 81       	ld	r18, Z
 5a4:	32 2f       	mov	r19, r18
 5a6:	2f e7       	ldi	r18, 0x7F	; 127
 5a8:	23 27       	eor	r18, r19
 5aa:	fc 01       	movw	r30, r24
 5ac:	20 83       	st	Z, r18
 5ae:	06 c0       	rjmp	.+12     	; 0x5bc <engine_start+0x44>
		}
	else
		led_flash = 1;
 5b0:	81 e0       	ldi	r24, 0x01	; 1
 5b2:	90 e0       	ldi	r25, 0x00	; 0
 5b4:	90 93 1e 01 	sts	0x011E, r25
 5b8:	80 93 1d 01 	sts	0x011D, r24
 5bc:	df 91       	pop	r29
 5be:	cf 91       	pop	r28
 5c0:	08 95       	ret

000005c2 <_exit>:
 5c2:	f8 94       	cli

000005c4 <__stop_program>:
 5c4:	ff cf       	rjmp	.-2      	; 0x5c4 <__stop_program>
