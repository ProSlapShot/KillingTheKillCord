
RotaryEnc.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000092  00800100  00000332  000003c6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000332  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000007  00800192  00800192  00000458  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000458  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000000d0  00000000  00000000  00000488  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000609  00000000  00000000  00000558  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000003cf  00000000  00000000  00000b61  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000384  00000000  00000000  00000f30  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000001ac  00000000  00000000  000012b4  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000233  00000000  00000000  00001460  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000002e0  00000000  00000000  00001693  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000000c0  00000000  00000000  00001973  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__ctors_end>
   4:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
   8:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
   c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  10:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__vector_4>
  14:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  18:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  1c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  20:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  24:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  28:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  2c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  30:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  34:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  38:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  3c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  40:	0c 94 30 01 	jmp	0x260	; 0x260 <__vector_16>
  44:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  48:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  4c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  50:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  54:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  58:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  5c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  60:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  64:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  68:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  6c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  70:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  74:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  78:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>

0000007c <__ctors_end>:
  7c:	11 24       	eor	r1, r1
  7e:	1f be       	out	0x3f, r1	; 63
  80:	cf ef       	ldi	r28, 0xFF	; 255
  82:	d0 e1       	ldi	r29, 0x10	; 16
  84:	de bf       	out	0x3e, r29	; 62
  86:	cd bf       	out	0x3d, r28	; 61

00000088 <__do_copy_data>:
  88:	11 e0       	ldi	r17, 0x01	; 1
  8a:	a0 e0       	ldi	r26, 0x00	; 0
  8c:	b1 e0       	ldi	r27, 0x01	; 1
  8e:	e2 e3       	ldi	r30, 0x32	; 50
  90:	f3 e0       	ldi	r31, 0x03	; 3
  92:	02 c0       	rjmp	.+4      	; 0x98 <__do_copy_data+0x10>
  94:	05 90       	lpm	r0, Z+
  96:	0d 92       	st	X+, r0
  98:	a2 39       	cpi	r26, 0x92	; 146
  9a:	b1 07       	cpc	r27, r17
  9c:	d9 f7       	brne	.-10     	; 0x94 <__do_copy_data+0xc>

0000009e <__do_clear_bss>:
  9e:	21 e0       	ldi	r18, 0x01	; 1
  a0:	a2 e9       	ldi	r26, 0x92	; 146
  a2:	b1 e0       	ldi	r27, 0x01	; 1
  a4:	01 c0       	rjmp	.+2      	; 0xa8 <.do_clear_bss_start>

000000a6 <.do_clear_bss_loop>:
  a6:	1d 92       	st	X+, r1

000000a8 <.do_clear_bss_start>:
  a8:	a9 39       	cpi	r26, 0x99	; 153
  aa:	b2 07       	cpc	r27, r18
  ac:	e1 f7       	brne	.-8      	; 0xa6 <.do_clear_bss_loop>
  ae:	0e 94 5d 00 	call	0xba	; 0xba <main>
  b2:	0c 94 97 01 	jmp	0x32e	; 0x32e <_exit>

000000b6 <__bad_interrupt>:
  b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ba <main>:



int main(void)
{
	uart_init();
  ba:	0e 94 54 01 	call	0x2a8	; 0x2a8 <uart_init>
	timer_init();
  be:	0e 94 27 01 	call	0x24e	; 0x24e <timer_init>
	rot_init();
  c2:	0e 94 65 00 	call	0xca	; 0xca <rot_init>
	sei();
  c6:	78 94       	sei
  c8:	ff cf       	rjmp	.-2      	; 0xc8 <main+0xe>

000000ca <rot_init>:
static uint8_t rtr_pos_two = 0;
static uint8_t sel = 0;

void rot_init()
{
		RTR_DDR |= ~pins; //Set Port C as inputs
  ca:	81 b1       	in	r24, 0x01	; 1
  cc:	81 b9       	out	0x01, r24	; 1
		RTR_PORT |= pins; // Enable pull up resistors
  ce:	82 b1       	in	r24, 0x02	; 2
  d0:	8f ef       	ldi	r24, 0xFF	; 255
  d2:	82 b9       	out	0x02, r24	; 2
		
		PCICR = _BV(PCIE0); //Enable interrupts on Port B
  d4:	91 e0       	ldi	r25, 0x01	; 1
  d6:	90 93 68 00 	sts	0x0068, r25
		PCMSK0 |= pins; //Set pins on Port B as interrupts	
  da:	eb e6       	ldi	r30, 0x6B	; 107
  dc:	f0 e0       	ldi	r31, 0x00	; 0
  de:	90 81       	ld	r25, Z
  e0:	80 83       	st	Z, r24
		
		DDRD |= _BV(PIND3);			//Rotary Select Pin	
  e2:	53 9a       	sbi	0x0a, 3	; 10
		PORTD |= _BV(PIND3);
  e4:	5b 9a       	sbi	0x0b, 3	; 11
			
		tmp_two = (RTR_PIN & pins);		// Initial encoder status (2)
  e6:	80 b1       	in	r24, 0x00	; 0
  e8:	80 93 00 01 	sts	0x0100, r24
		
		PORTD &= ~_BV(PIND3);
  ec:	5b 98       	cbi	0x0b, 3	; 11
		tmp_one = (RTR_PIN & pins);		
  ee:	80 b1       	in	r24, 0x00	; 0
  f0:	80 93 01 01 	sts	0x0101, r24
  f4:	08 95       	ret

000000f6 <__vector_4>:
}

ISR(PCINT0_vect)
{
  f6:	1f 92       	push	r1
  f8:	0f 92       	push	r0
  fa:	0f b6       	in	r0, 0x3f	; 63
  fc:	0f 92       	push	r0
  fe:	11 24       	eor	r1, r1
 100:	8f 93       	push	r24
 102:	9f 93       	push	r25
	if(!sel){
 104:	80 91 94 01 	lds	r24, 0x0194
 108:	81 11       	cpse	r24, r1
 10a:	0d c0       	rjmp	.+26     	; 0x126 <__vector_4+0x30>
		waiting_one |= (RTR_PIN & pins) ^ tmp_one;		//Need to mask pins
 10c:	90 b1       	in	r25, 0x00	; 0
 10e:	80 91 01 01 	lds	r24, 0x0101
 112:	89 27       	eor	r24, r25
 114:	90 91 98 01 	lds	r25, 0x0198
 118:	89 2b       	or	r24, r25
 11a:	80 93 98 01 	sts	0x0198, r24
		tmp_one = (RTR_PIN & pins);
 11e:	80 b1       	in	r24, 0x00	; 0
 120:	80 93 01 01 	sts	0x0101, r24
 124:	0c c0       	rjmp	.+24     	; 0x13e <__vector_4+0x48>
	}
	else{
		waiting_two |= (RTR_PIN & pins) ^ tmp_two;		//Need to mask pins
 126:	90 b1       	in	r25, 0x00	; 0
 128:	80 91 00 01 	lds	r24, 0x0100
 12c:	89 27       	eor	r24, r25
 12e:	90 91 96 01 	lds	r25, 0x0196
 132:	89 2b       	or	r24, r25
 134:	80 93 96 01 	sts	0x0196, r24
		tmp_two = (RTR_PIN & pins);
 138:	80 b1       	in	r24, 0x00	; 0
 13a:	80 93 00 01 	sts	0x0100, r24
	}
}
 13e:	9f 91       	pop	r25
 140:	8f 91       	pop	r24
 142:	0f 90       	pop	r0
 144:	0f be       	out	0x3f, r0	; 63
 146:	0f 90       	pop	r0
 148:	1f 90       	pop	r1
 14a:	18 95       	reti

0000014c <rtr_value>:

uint8_t rtr_value()
{
	return RTR_PIN & pins;
 14c:	80 b1       	in	r24, 0x00	; 0
}
 14e:	08 95       	ret

00000150 <rtr_position>:


uint8_t rtr_position(uint8_t x)
{
 150:	cf 93       	push	r28
 152:	df 93       	push	r29
	if(!x){
 154:	81 11       	cpse	r24, r1
 156:	19 c0       	rjmp	.+50     	; 0x18a <rtr_position+0x3a>
		PORTD |= _BV(PIND3);
 158:	5b 9a       	sbi	0x0b, 3	; 11
		if (waiting_one)
 15a:	80 91 98 01 	lds	r24, 0x0198
 15e:	88 23       	and	r24, r24
 160:	89 f0       	breq	.+34     	; 0x184 <rtr_position+0x34>
 162:	c0 e0       	ldi	r28, 0x00	; 0
		{
			uint8_t i = 0;
			
			for(i=0 ; i<=127 ; i++)
			{
				if(rtrlut[i] == rtr_value())
 164:	ec 2f       	mov	r30, r28
 166:	f0 e0       	ldi	r31, 0x00	; 0
 168:	ee 5e       	subi	r30, 0xEE	; 238
 16a:	fe 4f       	sbci	r31, 0xFE	; 254
 16c:	d0 81       	ld	r29, Z
 16e:	0e 94 a6 00 	call	0x14c	; 0x14c <rtr_value>
 172:	d8 13       	cpse	r29, r24
 174:	04 c0       	rjmp	.+8      	; 0x17e <rtr_position+0x2e>
				{
					rtr_pos_one = i;
 176:	c0 93 97 01 	sts	0x0197, r28
					return i;
 17a:	8c 2f       	mov	r24, r28
 17c:	22 c0       	rjmp	.+68     	; 0x1c2 <rtr_position+0x72>
		PORTD |= _BV(PIND3);
		if (waiting_one)
		{
			uint8_t i = 0;
			
			for(i=0 ; i<=127 ; i++)
 17e:	cf 5f       	subi	r28, 0xFF	; 255
 180:	8a f7       	brpl	.-30     	; 0x164 <rtr_position+0x14>
 182:	1c c0       	rjmp	.+56     	; 0x1bc <rtr_position+0x6c>
			}
			
			return RTR_INVALID;
		}
		
		return rtr_pos_one;
 184:	80 91 97 01 	lds	r24, 0x0197
 188:	1c c0       	rjmp	.+56     	; 0x1c2 <rtr_position+0x72>
	}
	else if(x){
		PORTD &= ~_BV(PIND3);
 18a:	5b 98       	cbi	0x0b, 3	; 11
		if (waiting_two)
 18c:	80 91 96 01 	lds	r24, 0x0196
 190:	88 23       	and	r24, r24
 192:	89 f0       	breq	.+34     	; 0x1b6 <rtr_position+0x66>
 194:	c0 e0       	ldi	r28, 0x00	; 0
		{
			uint8_t i = 0;
			
			for(i=0 ; i<=127 ; i++)
			{
				if(rtrlut[i] == rtr_value())
 196:	ec 2f       	mov	r30, r28
 198:	f0 e0       	ldi	r31, 0x00	; 0
 19a:	ee 5e       	subi	r30, 0xEE	; 238
 19c:	fe 4f       	sbci	r31, 0xFE	; 254
 19e:	d0 81       	ld	r29, Z
 1a0:	0e 94 a6 00 	call	0x14c	; 0x14c <rtr_value>
 1a4:	d8 13       	cpse	r29, r24
 1a6:	04 c0       	rjmp	.+8      	; 0x1b0 <rtr_position+0x60>
				{
					rtr_pos_two = i;
 1a8:	c0 93 95 01 	sts	0x0195, r28
					return i;
 1ac:	8c 2f       	mov	r24, r28
 1ae:	09 c0       	rjmp	.+18     	; 0x1c2 <rtr_position+0x72>
		PORTD &= ~_BV(PIND3);
		if (waiting_two)
		{
			uint8_t i = 0;
			
			for(i=0 ; i<=127 ; i++)
 1b0:	cf 5f       	subi	r28, 0xFF	; 255
 1b2:	8a f7       	brpl	.-30     	; 0x196 <rtr_position+0x46>
 1b4:	05 c0       	rjmp	.+10     	; 0x1c0 <rtr_position+0x70>
			}
			
			return RTR_INVALID;
		}
		
		return rtr_pos_two;
 1b6:	80 91 95 01 	lds	r24, 0x0195
 1ba:	03 c0       	rjmp	.+6      	; 0x1c2 <rtr_position+0x72>
					rtr_pos_one = i;
					return i;
				}
			}
			
			return RTR_INVALID;
 1bc:	8f ef       	ldi	r24, 0xFF	; 255
 1be:	01 c0       	rjmp	.+2      	; 0x1c2 <rtr_position+0x72>
					rtr_pos_two = i;
					return i;
				}
			}
			
			return RTR_INVALID;
 1c0:	8f ef       	ldi	r24, 0xFF	; 255
		
		return rtr_pos_two;
	}
	else
	return RTR_INVALID;
}
 1c2:	df 91       	pop	r29
 1c4:	cf 91       	pop	r28
 1c6:	08 95       	ret

000001c8 <rtr_intrpt>:

void rtr_intrpt()
{
	if(!sel){
 1c8:	80 91 94 01 	lds	r24, 0x0194
 1cc:	81 11       	cpse	r24, r1
 1ce:	20 c0       	rjmp	.+64     	; 0x210 <rtr_intrpt+0x48>
		static uint8_t buff_one = 0;
		rtr_pos_one = rtr_position(sel);
 1d0:	0e 94 a8 00 	call	0x150	; 0x150 <rtr_position>
 1d4:	80 93 97 01 	sts	0x0197, r24
		if(buff_one != rtr_pos_one){
 1d8:	90 91 93 01 	lds	r25, 0x0193
 1dc:	89 17       	cp	r24, r25
 1de:	81 f0       	breq	.+32     	; 0x200 <rtr_intrpt+0x38>
			uart_str("\nRotary ");
 1e0:	82 e0       	ldi	r24, 0x02	; 2
 1e2:	91 e0       	ldi	r25, 0x01	; 1
 1e4:	0e 94 68 01 	call	0x2d0	; 0x2d0 <uart_str>
			uart_number(sel);
 1e8:	80 91 94 01 	lds	r24, 0x0194
 1ec:	0e 94 77 01 	call	0x2ee	; 0x2ee <uart_number>
			uart_str(" Pos :");
 1f0:	8b e0       	ldi	r24, 0x0B	; 11
 1f2:	91 e0       	ldi	r25, 0x01	; 1
 1f4:	0e 94 68 01 	call	0x2d0	; 0x2d0 <uart_str>
			uart_number(rtr_pos_one);
 1f8:	80 91 97 01 	lds	r24, 0x0197
 1fc:	0e 94 77 01 	call	0x2ee	; 0x2ee <uart_number>
		}
		buff_one = rtr_pos_one;
 200:	80 91 97 01 	lds	r24, 0x0197
 204:	80 93 93 01 	sts	0x0193, r24
		sel = 1;
 208:	81 e0       	ldi	r24, 0x01	; 1
 20a:	80 93 94 01 	sts	0x0194, r24
 20e:	08 95       	ret
	}else{
		static uint8_t buff_two = 0;
		rtr_pos_two = rtr_position(sel);
 210:	0e 94 a8 00 	call	0x150	; 0x150 <rtr_position>
 214:	80 93 95 01 	sts	0x0195, r24
		if(buff_two != rtr_pos_two){
 218:	90 91 92 01 	lds	r25, 0x0192
 21c:	89 17       	cp	r24, r25
 21e:	81 f0       	breq	.+32     	; 0x240 <rtr_intrpt+0x78>
			uart_str("\nRotary ");
 220:	82 e0       	ldi	r24, 0x02	; 2
 222:	91 e0       	ldi	r25, 0x01	; 1
 224:	0e 94 68 01 	call	0x2d0	; 0x2d0 <uart_str>
			uart_number(sel);
 228:	80 91 94 01 	lds	r24, 0x0194
 22c:	0e 94 77 01 	call	0x2ee	; 0x2ee <uart_number>
			uart_str(" Pos :");
 230:	8b e0       	ldi	r24, 0x0B	; 11
 232:	91 e0       	ldi	r25, 0x01	; 1
 234:	0e 94 68 01 	call	0x2d0	; 0x2d0 <uart_str>
			uart_number(rtr_pos_two);
 238:	80 91 95 01 	lds	r24, 0x0195
 23c:	0e 94 77 01 	call	0x2ee	; 0x2ee <uart_number>
		}
		buff_two = rtr_pos_two;
 240:	80 91 95 01 	lds	r24, 0x0195
 244:	80 93 92 01 	sts	0x0192, r24
		sel = 0;
 248:	10 92 94 01 	sts	0x0194, r1
 24c:	08 95       	ret

0000024e <timer_init>:
//static uint8_t[8] rot_one = {0,0,0,0,0,0,0,0};
//static uint8_t[8] rot_two = {0,0,0,0,0,0,0,0};

void timer_init()
{
	OCR0A = F_CPU / 1024 / 50;   // Set up compare value for 50 Hz interrupt generation.
 24e:	8a ee       	ldi	r24, 0xEA	; 234
 250:	87 bd       	out	0x27, r24	; 39
	TCCR0A = (1 << WGM01);               // Enable CTC mode
 252:	82 e0       	ldi	r24, 0x02	; 2
 254:	84 bd       	out	0x24, r24	; 36
	TIMSK0 = _BV(OCIE0A);                // Enable Timer0 Compare Match A interrupt
 256:	80 93 6e 00 	sts	0x006E, r24
	TCCR0B = (1 << CS02) | (0 << CS01) | (1 << CS00); // Initilise timer1 with /1024 prescaler	
 25a:	85 e0       	ldi	r24, 0x05	; 5
 25c:	85 bd       	out	0x25, r24	; 37
 25e:	08 95       	ret

00000260 <__vector_16>:
}

ISR(TIMER0_COMPA_vect)
{
 260:	1f 92       	push	r1
 262:	0f 92       	push	r0
 264:	0f b6       	in	r0, 0x3f	; 63
 266:	0f 92       	push	r0
 268:	11 24       	eor	r1, r1
 26a:	2f 93       	push	r18
 26c:	3f 93       	push	r19
 26e:	4f 93       	push	r20
 270:	5f 93       	push	r21
 272:	6f 93       	push	r22
 274:	7f 93       	push	r23
 276:	8f 93       	push	r24
 278:	9f 93       	push	r25
 27a:	af 93       	push	r26
 27c:	bf 93       	push	r27
 27e:	ef 93       	push	r30
 280:	ff 93       	push	r31
	rtr_intrpt();
 282:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <rtr_intrpt>
	
	
	//rtr_position();
	//uart_data(rtr_position());
	//uart_data(rtr_value());
}
 286:	ff 91       	pop	r31
 288:	ef 91       	pop	r30
 28a:	bf 91       	pop	r27
 28c:	af 91       	pop	r26
 28e:	9f 91       	pop	r25
 290:	8f 91       	pop	r24
 292:	7f 91       	pop	r23
 294:	6f 91       	pop	r22
 296:	5f 91       	pop	r21
 298:	4f 91       	pop	r20
 29a:	3f 91       	pop	r19
 29c:	2f 91       	pop	r18
 29e:	0f 90       	pop	r0
 2a0:	0f be       	out	0x3f, r0	; 63
 2a2:	0f 90       	pop	r0
 2a4:	1f 90       	pop	r1
 2a6:	18 95       	reti

000002a8 <uart_init>:


void uart_init(void)
{
	/* Configure 9600 baud, 8-bit, no parity and one stop bit */
	UBRR0H = (F_CPU/(UART_BAUD*16L)-1) >> 8;
 2a8:	10 92 c5 00 	sts	0x00C5, r1
	UBRR0L = (F_CPU/(UART_BAUD*16L)-1);
 2ac:	8d e4       	ldi	r24, 0x4D	; 77
 2ae:	80 93 c4 00 	sts	0x00C4, r24
	UCSR0B = _BV(RXEN0) | _BV(TXEN0);
 2b2:	88 e1       	ldi	r24, 0x18	; 24
 2b4:	80 93 c1 00 	sts	0x00C1, r24
	UCSR0C = _BV(UCSZ00) | _BV(UCSZ01);
 2b8:	86 e0       	ldi	r24, 0x06	; 6
 2ba:	80 93 c2 00 	sts	0x00C2, r24
 2be:	08 95       	ret

000002c0 <uart_tx>:


void uart_tx(char ch)
{

	while (!(UCSR0A & _BV(UDRE0)));
 2c0:	e0 ec       	ldi	r30, 0xC0	; 192
 2c2:	f0 e0       	ldi	r31, 0x00	; 0
 2c4:	90 81       	ld	r25, Z
 2c6:	95 ff       	sbrs	r25, 5
 2c8:	fd cf       	rjmp	.-6      	; 0x2c4 <uart_tx+0x4>
	UDR0 = ch;
 2ca:	80 93 c6 00 	sts	0x00C6, r24
 2ce:	08 95       	ret

000002d0 <uart_str>:
	UDR0 = d;

}

void uart_str(char *str)
{
 2d0:	cf 93       	push	r28
 2d2:	df 93       	push	r29
 2d4:	ec 01       	movw	r28, r24
	int i;
	for(i=0; str[i]; i++) uart_tx(str[i]);
 2d6:	88 81       	ld	r24, Y
 2d8:	88 23       	and	r24, r24
 2da:	31 f0       	breq	.+12     	; 0x2e8 <uart_str+0x18>
 2dc:	21 96       	adiw	r28, 0x01	; 1
 2de:	0e 94 60 01 	call	0x2c0	; 0x2c0 <uart_tx>
 2e2:	89 91       	ld	r24, Y+
 2e4:	81 11       	cpse	r24, r1
 2e6:	fb cf       	rjmp	.-10     	; 0x2de <uart_str+0xe>
}
 2e8:	df 91       	pop	r29
 2ea:	cf 91       	pop	r28
 2ec:	08 95       	ret

000002ee <uart_number>:

void uart_number(uint8_t x)			// Recursive function to print digits
{
 2ee:	cf 93       	push	r28
 2f0:	c8 2f       	mov	r28, r24
	if((x/10)!=0)
 2f2:	8a 30       	cpi	r24, 0x0A	; 10
 2f4:	48 f0       	brcs	.+18     	; 0x308 <uart_number+0x1a>
	uart_number(x/10);
 2f6:	8d ec       	ldi	r24, 0xCD	; 205
 2f8:	c8 9f       	mul	r28, r24
 2fa:	81 2d       	mov	r24, r1
 2fc:	11 24       	eor	r1, r1
 2fe:	86 95       	lsr	r24
 300:	86 95       	lsr	r24
 302:	86 95       	lsr	r24
 304:	0e 94 77 01 	call	0x2ee	; 0x2ee <uart_number>
	
	char conv = '0' + (x%10);		//Converts uint to char for easy logging
 308:	8d ec       	ldi	r24, 0xCD	; 205
 30a:	c8 9f       	mul	r28, r24
 30c:	81 2d       	mov	r24, r1
 30e:	11 24       	eor	r1, r1
 310:	86 95       	lsr	r24
 312:	86 95       	lsr	r24
 314:	86 95       	lsr	r24
 316:	88 0f       	add	r24, r24
 318:	98 2f       	mov	r25, r24
 31a:	99 0f       	add	r25, r25
 31c:	99 0f       	add	r25, r25
 31e:	89 0f       	add	r24, r25
 320:	c8 1b       	sub	r28, r24
 322:	8c 2f       	mov	r24, r28
	uart_tx(conv);
 324:	80 5d       	subi	r24, 0xD0	; 208
 326:	0e 94 60 01 	call	0x2c0	; 0x2c0 <uart_tx>
	//uart_data(x%10);	
 32a:	cf 91       	pop	r28
 32c:	08 95       	ret

0000032e <_exit>:
 32e:	f8 94       	cli

00000330 <__stop_program>:
 330:	ff cf       	rjmp	.-2      	; 0x330 <__stop_program>
